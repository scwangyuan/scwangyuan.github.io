{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"scwangyuan","url":"https://github.com/scwangyuan/scwangyuan.github.io"},"pages":[],"posts":[{"title":"牛客算法初级班总结","slug":"牛客算法初级班总结","date":"2018-10-22T13:05:14.000Z","updated":"2018-10-22T13:35:06.589Z","comments":true,"path":"2018/10/22/牛客算法初级班总结/","link":"","permalink":"https://github.com/scwangyuan/scwangyuan.github.io/2018/10/22/牛客算法初级班总结/","excerpt":"","text":"Welcome to scwangyuan’s blog! It is my very first blog. If you get any problems when you’re reading , You can contact me through the contact information on the blog or you can ask me on GitHub. 牛客算法初级班第一课总结####复杂度估算和排序算法（上） #####认识时间复杂度和空间复杂度时间复杂度是评价一个算法流程好坏的指标，常用O（读作big O） #####认识对数器对数器的概念和使用0，有一个你想要测的方法a，1，实现一个绝对正确但是复杂度不好的方法b，2，实现一个随机样本产生器3，实现比对的方法4，把方法a和方法b比对很多次来验证方法a是否正确。5，如果有一个样本使得比对出错，打印样本分析是哪个方法出错6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。 ######代码案例：冒泡排序的对数器： ######1.要测的方法123456789101112public static void sort(int[] arr) &#123; if(arr == null || arr.length &lt; 2) return; for(int end = arr.length-1;end &gt; 0;end--) &#123; for(int i = 0;i &lt; end;i++) &#123; if(arr[i] &gt; arr[i+1]) &#123; //自己实现的交换的方法 swap(arr, i, i+1); &#125; &#125; &#125; &#125; ######2.实现一个绝对正确即使复杂度不好的方法1234// for test 一个绝对正确的方法，调用java自带的排序方法public static void rightMethod(int[] arr) &#123; Arrays.sort(arr);&#125; ######3.实现一个随机样本产生器；12345678910111213141516171819// for test 随机数组生成器/* * Math.random() -&gt; double[0,1) * (int) ((size + 1) * Math.random()) -&gt; [0, size] * size = 6, size + 1 = 7 * Math.random() -&gt; [0,1) * 7 -&gt; [0,7)double * double -&gt; int[0,6] -&gt; int */public static int[] generateRandomArray(int size, int value) &#123; //产生的数组长度是[0, size] int[] arr = new int[(int) ((size + 1) * Math.random())]; //产生的数组中的数的范围是-value ~ value for(int i = 0;i &lt; arr.length;i++) &#123; arr[i] = (int) ((value + 1) * Math.random() - (int) (value * Math.random())); &#125; return arr;&#125; ######4.实现比对的方法；1234567891011121314//判断两个数组是否相等public static boolean isEqual(int[] arr1, int[] arr2) &#123; if((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) return false; if(arr1 == null &amp;&amp; arr2 == null) return true; if(arr1.length != arr2.length) return false; for(int i = 0;i &lt; arr1.length;i++) &#123; if(arr1[i] != arr2[i]) return false; &#125; return true;&#125; ######5.把方法a和方法b比对很多次来验证方法a是否正确 ######6.如果有一个样本使得比对出错，打印样本分析是哪个方法出错 ######7.当样本数量很多时比对测试依然正确，可以确定方法a已经正确1234567891011121314151617181920212223242526//主方法中：public static void main(String[] args) &#123; //testTime是测试次数 int testTime = 500000; int size = 10; int value = 100; boolean succeed = true; for(int i = 0;i &lt; testTime;i++) &#123; int[] arr1 = generateRandomArray(size, value); //拷贝数组，数组new出来的就是在栈中不同的空间中存放，内容相同 //copyArray(int[] arr)是自己实现的拷贝方法 int[] arr2 = copyArray(arr1); int[] arr3 = copyArray(arr1); sort(arr1); rightMethod(arr2); if(!isEqual(arr1, arr2)) &#123; succeed = false; //打印出错的数组，printArray是自习实现的打印的方法 printArray(arr3); break; &#125; &#125; //打印要测的部分是否正确 System.out.println(succeed ? \"succeed!\" : \"false..\");&#125; #####3）冒泡排序 1. 从第一个元素开始，比较相邻的一对元素。 2. 如果前面的比后面的大，交换它们。 3. 一轮遍历之后最大的元素一定会位于序列结尾。 4. 重复1-3，每次将剩下的元素中最大的放到剩下元素组成序列的结尾。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class BubbleSort &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int a[] =&#123;13,15,37,89,60,39,12,109,56,72&#125; ; int i = 0; int j = 0; for(i=0;i&lt;10;i++) System.out.print(a[i]+\" \"); System.out.println(); for(i=0;i&lt;a.length;i++) for(j=0;j&lt;a.length-i-1;j++) &#123; if(a[j]&gt;a[j+1]) &#123; int temp; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; for(i=0;i&lt;10;i++) System.out.print(a[i]+\" \"); &#125;&#125;#####4）选择排序算法思想： 将待排序序列分为两部分，一部分为有序序列，另一部分为无序序列。第一趟：从a[0]到a[n-1]中找到最小的数a[i]，然后将a[i]与a[0]交换，第二趟：从a[1]到a[n-1]中找到最小的数a[j]，然后将a[j]与a[1]交换,第三趟：从a[2]到a[n-1]中找到最小的数a[k],然后将a[k]与a[2]交换 ……2、实例分析： &#123;13,15,37,89,60,39,12,109,56,72&#125;第一趟 ：12 &#123;15,37,89,60,39,13,109,56,72&#125;第二趟：12 ，13 &#123;37,89,60,39,15,109,56,72&#125;第三趟：12 ，13 ，15 &#123;89,60,39,37,109,56,72&#125;……```bashpublic class SelectSort &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int a[] =&#123;13,15,37,89,60,39,12,109,56,72&#125; ; int i; int j; for(i = 0;i&lt;a.length;i++) System.out.print(a[i]+\" \"); System.out.println(); for(i = 0;i&lt;a.length;i++)&#123; int min = a[i]; for(j = i+1;j&lt;a.length;j++)&#123; if(min&gt;a[j])&#123; int temp; temp = min; min = a[j]; a[j] = temp; &#125; &#125; a[i] = min; &#125; for(i = 0;i&lt;a.length;i++) System.out.print(a[i]+\" \"); &#125;&#125; #####5）插入排序算法思想：1〉从第一个元素开始，该元素可以认为已经被排序 2〉取出第一个未排序元素存放在临时变量temp中，在已经排序的元素序列中从后往前扫描，逐一比较 3〉如果temp小于已排序元素，将该元素移到下个位置 4〉重复步骤3〉，直到找到已排序的元素小于或者等于 实例分析：{13,15,37,89,60,39,12,109,56,72} 第一趟： 13 {15,37,89,60,39,12,109,56,72} temp = 15 temp&gt;13 第二趟： 13 ,15 { 37,89,60,39,12,109,56,72} temp = 37 temp&gt;15 temp&gt;13 第三趟： 13，15 ，37 {89,60,39,12,109,56,72} temp = 89 temp&gt;37 temp&gt;15 temp&gt;13 第三趟： 13，15 ，37 ，89 {60,39,12,109,56,72} temp =60 temp&lt; 89：6089 13，15 ，37 ， 60，89 {39,12,109,56,72} temp&gt;37 temp&gt;15 temp&gt;13 第四趟： 13，15 ，37 ， 60，89 {39,12,109,56,72} temp = 39 temp&lt;89： 3989 13，15 ，37 ， 60，39，89 {12,109,56,72} temp&lt;60 ： 3960 13，15 ，37 ， 39，60，89 {12,109,56,72} temp&gt;37 temp&gt;15 temp &gt;13 第五趟： 13，15 ，37 ， 39，60，89 {12,109,56,72} temp = 12temp&lt;89 ：1289 13，15 ，37 ，39，60， 12，89 {109,56,72} temp&lt;60：1260 13，15 ，37 ，39，12，60，89 {109,56,72} temp&lt;39 ：1239 13，15 ，37 ，12，39，60，89 {109,56,72} temp&lt;37 ：1237 13，15 ，12 ，37 ，39，60，89 {109,56,72} temp&lt;15： 1215 13，12，15 ，37 ，39，60，89 {109,56,72} temp&lt;13 ：1213 12，13，15 ，37 ，39，60，89 {109,56,72} 第六趟： 12，13，15 ，37 ，39，60，89 {109,56,72} temp = 109 ……1234567891011121314151617181920212223242526272829303132import java.util.Arrays;/*** 插入排序* @author xcbeyond**/public class InsertSort &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int a[] =&#123;13,15,37,89,60,39,12,109,56,72&#125; ; a = insertSort(a); String s = Arrays.toString(a); System.out.println(s); &#125; public static int[] insertSort(int[] ary)&#123; for(int i = 1;i &lt; ary.length;i++)&#123; int temp = ary[i]; int j; for(j = i-1;j&gt;=0;j--)&#123; if(temp &lt; ary[j])&#123; ary[j+1] = ary[j]; &#125; else break; //找到插入位置 &#125; ary[j+1] = temp; &#125; return ary; &#125;&#125; #####6）如何分析递归过程的时间复杂度 #####7）归并排序归并排序的过程，将数据分解后，再进行合并 原理：归并的每一次合并都是将两个有序组合并为一个有序组，合并好后的有序组，再和另外的有序组继续合并，最终可以得到一个完整的有序数组累加的原理这里主要就是利用合并的过程中，两个有序组都是有序的进行判断累加，我们以上图的数据为3,5组和数据为8,9组合并的过程为例，来计算累加的结果从上面的图可以看出，如果p1索引的值小于p2索引的值，那么这一次排序的过程可以计算右侧数组比3大的数有2个（因为每一组都是有序的），然后索引p1向右移动从上面的图可以看出，p1索引的值小于p2索引的值，那么这一次排序过程可以计算出右边比5大的数有2个 总结：上面两个有序组合并为一个有序组时，累加的小和的值为： 32+52=16 #####8）小和问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static int smallSum(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; return mergeSort(arr,0,arr.length-1); &#125; public static int mergeSort(int[] arr, int L, int R) &#123; if (L == R) &#123; return 0; &#125; int mid = (L + R) &gt;&gt;&gt;1;//这里是防止数据溢出 return mergeSort(arr, L, mid) + mergeSort(arr, mid + 1, R) + merge(arr, L, mid, R); &#125; //合并的过程 public static int merge(int[] arr, int L, int mid, int R) &#123; //准备一个临时数组，长度和传进来的arr一样 int[] temp = new int[R - L + 1]; int p1 = L; int p2 = mid + 1; //临时数组temp的索引起始变量 int i = 0; //小和结果的变量 int result = 0; //合并数组的循环，并计算小和 while (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123; if (arr[p1] &lt; arr[p2]) &#123; //计算小和的累加结果，(R-p2+1)为比数arr[p1]大的数量 result += (R - p2 + 1) * arr[p1]; temp[i] = arr[p1]; p1++; i++; &#125; else &#123; temp[i] = arr[p2]; p2++; i++; &#125; &#125; while (p1 &lt;= mid) &#123; temp[i] = arr[p1]; i++; p1++; &#125; while (p2 &lt;= R) &#123; temp[i] = arr[p2]; i++; p2++; &#125; //这里是将临时数组temp的元素重新赋值给传入进来的arr for (int j = 0; j &lt; temp.length; j++) &#123; arr[L + j] = temp[j]; &#125; return result; &#125;","categories":[],"tags":[]},{"title":"Git常用命令速查","slug":"Git常用命令","date":"2018-09-23T15:25:49.000Z","updated":"2018-09-26T01:56:40.532Z","comments":true,"path":"2018/09/23/Git常用命令/","link":"","permalink":"https://github.com/scwangyuan/scwangyuan.github.io/2018/09/23/Git常用命令/","excerpt":"","text":"Welcome to scwangyuan’s blog! It is my very first blog. If you get any problems when you’re reading , You can contact me through the contact information on the blog or you can ask me on GitHub. hexo常用命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publish #发布草稿hexo g == hexo generate #生成静态网页hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 Git 常用命令速查更多命令：https://segmentfault.com/a/1190000002632530","categories":[],"tags":[{"name":"Git 命令","slug":"Git-命令","permalink":"https://github.com/scwangyuan/scwangyuan.github.io/tags/Git-命令/"}]},{"title":"update_blog步骤","slug":"update-blog","date":"2018-09-23T12:48:08.000Z","updated":"2018-09-25T06:08:12.922Z","comments":true,"path":"2018/09/23/update-blog/","link":"","permalink":"https://github.com/scwangyuan/scwangyuan.github.io/2018/09/23/update-blog/","excerpt":"","text":"Welcome to scwangyuan’s blog! It is my very first blog. If you get any problems when you’re reading , You can contact me through the contact information on the blog or you can ask me on GitHub. update_blog步骤创建新文章·在test文件夹下Git bash here1$ hexo new 'update_blog' 该命令会在_posts文件夹下生成update_blog文件夹以及update_blog.md文件 ·在写文章时，将文件的其他资源放进update_blog文件夹中资源管理详情链接 ·首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 ######· 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save（需要等待一段时间）。 ·完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。下面的语句就是在.md文件中使用的1&#123;% asset_img p1-1.jpg This is an example image %&#125; markdown也可以嵌入表格，格式就和html的一样，代码如下。1234567891011121314151617181920212223242526&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;我&lt;/td&gt; &lt;td&gt;超级&lt;/td&gt; &lt;td&gt;可爱&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;我&lt;/td&gt; &lt;td&gt;超级&lt;/td&gt; &lt;td&gt;机智&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;我&lt;/td&gt; &lt;td&gt;超级&lt;/td&gt; &lt;td&gt;帅气&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 比较常用的有:12加粗：&lt;b&gt;换行：&lt;br&gt; 注：将图片放在与.bat文件名相同的文件夹中因为有缓存，所以更改内容后，一定要多刷新几次才能看到效果 总结：命令1.hexo new ‘update_blog’ #创建新的帖子2.hexo g -d #重新生成静态网页并部署 创建分支，解决多端编写问题：https://haoshuai6.github.io/2016-10-28-hexo-github.html","categories":[],"tags":[]},{"title":"Hexo+Github搭建博客","slug":"我的新帖子","date":"2018-09-22T11:11:44.000Z","updated":"2018-09-25T02:17:18.464Z","comments":true,"path":"2018/09/22/我的新帖子/","link":"","permalink":"https://github.com/scwangyuan/scwangyuan.github.io/2018/09/22/我的新帖子/","excerpt":"","text":"Welcome to scwangyuan’s blog! It is my very first blog. If you get any problems when you’re reading , You can contact me through the contact information on the blog or you can ask me on GitHub. Hexo+Github搭建博客先展示展示成果吧，在远程成功部署自己的博客，接下来就是美化我的博客了（此处笑脸，还好我没放弃）采坑太多，下面就总结一下吧 刚开始在网上找了几篇教程感觉还不错，就开始动手做了，一实际操作就不是那么回事儿了，废话不多说，直接说要点在采坑之后想到直接看视频会不会更加清楚，因为你知道在哪个文件夹下用什么命令，更清楚也更直观。于是找到了哔哩哔哩上的视频，由于直接看的hexo+github 搭建blog，于是又采坑了，没办法，还是决定从头看，从up主的第一个视频开始看（一共也就3个），反复看，终于成功了，另外up主推荐看“廖雪峰”视频教程，这个我还是比较认可的，之前看过“廖雪峰”的其他教程。下面放上他们的链接：up主：http://www.bilibili.com/video/av23853294?share_medium=android&amp;share_source=qq&amp;bbid=Nwc0AWJTYVUxVDZUKFQoinfoc&amp;ts=1537664702601廖雪峰：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 1.Git安装Git 下载对应版本，常规安装就好 安装教程 2.注册Github3.将git与github连接起来·获取公钥1$ ssh-keygen ·将获取的公钥在github上进行配置注：将视频里的步骤搬过来了，坑就是ssh的获取不像up主那样，我是直接没有找到.ssh文件夹（一把辛酸泪），调整隐式文件可查看后，在使用 ssh-keygen 命令后继续enter,大概有3次之后，你就可以在.ssh文件中找到秘钥了，然后按照将git与github关联。·创建一个名为 .git 的子目录1$ git init ·一个已有的本地仓库与远程仓库关联1$ git remote add origin http://github.com/scwangyuan/project1.git ·本地仓库的内容推送到GitHub仓库1$ git push origin master More info: Git命令 注：本地创建index.html文件x先保存到本地仓库，再提交添加到缓存区的文件上传到远程仓库1$ git add index.html 1$ git commit -m 'demo' 4.Hexo配置·在blog中创建一个名为 test 的子目录1$ hexo init test ·安装hexo123$ hexo install 或命令 npm install hexo-cli -g ·安装hexo部署到git page的deployer1$ npm install hexo-deployer-git --save ·重新部署1$ hexo g -d 本地链接：http://localhost:4000/1$ hexo s 5.博客编写利用markdown 编写博客将编写好的内容放到 D:\\blog\\test\\source_posts常见命令：https://baike.baidu.com/item/markdown/3245829?fr=aladdin 标题：#Header 1 每增加一个 # 表示更深入层次的内容 照片：![This is a title]() 链接 :[Title](URL) 代码：使用三个回勾号``` ´´´ &lt;header&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;/header&gt; ´´´ 加粗 :**Bold** 斜体字 :*Italics* *高亮 :==text== 段落 : 段落之间空一行 换行符 : 一行结束时输入两个空格 列表 :* 添加星号成为一个新的列表项。 引用 :&gt; 引用内容 内嵌代码 : `alert(&apos;Hello World&apos;);` 画水平线 (HR) :-------- 方框：- [ ] -","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-09-22T07:53:20.267Z","updated":"2018-09-22T07:53:20.267Z","comments":true,"path":"2018/09/22/hello-world/","link":"","permalink":"https://github.com/scwangyuan/scwangyuan.github.io/2018/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}